package io.r2.j8p.t7_streams;

import java.io.BufferedReader;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;

/**
 *  Describe the Stream interface and pipelines; create a stream by using the Arrays.stream() and  IntStream.range() methods; identify the lambda operations that are lazy
 */
public class StreamBasics {

    // how to create a stream?
    public void create() throws Exception {

        // any empty stream
        Stream.empty();

        // a stream can be created from a collection
        new ArrayList<Integer>().stream();

        // from an array
        Arrays.stream(new int[1024]);

        // with a builder
        Stream.<String>builder().add("a").add("b").build();

        // with fixed elements
        Stream.<String>of("a", "b", "c");

        // lines from an bufferedread
        new BufferedReader(null).lines();

        // using Files
        Files.lines(null);

        // generated by a supplier
        Stream<Integer> is = Stream.generate(() -> 1);

        // seeded by an UnaryOperator
        IntStream.iterate(1, (x) -> x+1);

        // two streams concatenated
        Stream.concat( Stream.of("a", "b"), Stream.empty() );

        // by ranges of int or long stream
        LongStream.range(100, 200);
        IntStream.rangeClosed(10, 20);

        // possibly other sources would work as well

        // besides object type Stream, native stream types also exist:
        // IntStream, LongStream, DoubleStream
    }

    // basic intermediate operations
    // these operations result in a new stream, or the same stream modified, and are chainable
    public void basicIntermediateOps() {
        Stream<Integer> s = Stream.generate(() -> 1);

        // set parallel/sequential operation
        s.parallel();
        s.sequential();

        // set to unordered
        s.unordered();

        // set onCLose handler (this is very special)
        s.onClose(()->{ /* .. */ });

        // sets a peek handler, called on every element (this is also very special)
        s.peek(System.out::println);

        // filter with a predicate
        s.filter((x) -> x < 10);

        // skip elements
        s.skip(3);

        // and limit number of elements
        s.limit(5);

        // can be sorted
        // this is a bounded operation
        s.sorted();

        // can also be sorted by a comparator
        s.sorted(Comparator.reverseOrder());

        // keep only distict elements
        // this is a bounded operation
        s.distinct();
    }

    // basic terminal operations
    // these operations can be only at the end of the chain, after these the stream will be consumed
    public void basicTerminalOps() {
        Stream<Integer> s = Stream.generate(() -> 1).limit(50);

        // forEach and forEachOrdered (this guarantees ordered processing) passes every value to a consumer
        s.forEach(System.out::println);
        s.forEachOrdered(System.out::println);

        // streams may also be collected to an array - generic array, or typed, with an array allocator
        Object[] a = s.toArray();
        Integer[] aa = s.toArray(Integer[]::new);
    }

    // find and match operations are terminal operations on the stream
    // @see io.r2.j8p.t6_collections.CollectionSearch
    public void basicSearchMatch() {
        Stream<Integer> s = Stream.generate(() -> 1).limit(50);

        s.allMatch((x) -> x > 5);
        s.anyMatch((x) -> x < 5);
        s.noneMatch((x) -> x == 3);

        s.findAny();
        s.findFirst();

    }
}
